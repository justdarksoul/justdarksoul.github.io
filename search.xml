<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue.js 第二天]]></title>
    <url>%2F2017%2F08%2F02%2Fvue02%2F</url>
    <content type="text"><![CDATA[自定义组件]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 第一天]]></title>
    <url>%2F2017%2F08%2F02%2Fvue01%2F</url>
    <content type="text"><![CDATA[渲染、循环、处理、绑定、事件 声明-渲染数据，所有元素都是响应式的 12345678910&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123;el: &apos;#app&apos;,data: &#123; message: &apos;Hello Vue!&apos;&#125;&#125;) 单向绑定/双向绑定(v-bind/v-model) 指令带有前缀 v-，表示它们是 Vue 提供的特殊属性,v-model往往用于表单控件中，v-bind往往用在非交互的地方（非表单控件的地方） 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;单向绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125; &lt;h1&gt;双向绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; name: &apos;abcdefg&apos; &#125;,&#125;) v-if/v-else vue实例中添加一个data属性的show，初始化值为true或者false，v-else不能单独使用，只能跟在v-if后面，不需要绑定属性，v-if可以单独使用，可以不绑定特定属性,v-if是通过创建和删除元素来达到显示隐藏的效果,而v-show是通过控制css属性来显示或隐藏,v-show的初始化要慢点，但是如果有频繁的显示/隐藏操作,v-if的消耗就要大很多了 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;v-if/v-else演示&lt;/h1&gt; &lt;div v-if=&quot;show&quot;&gt;前端大法好&lt;/div&gt; &lt;div v-else&gt;前端大法棒&lt;/div&gt; &lt;div v-show=&quot;show&quot;&gt;前端小可爱&lt;/div&gt; &lt;div v-show=&quot;!show&quot;&gt;前端小可爱666666&lt;/div&gt; &lt;button @click=&quot;show=!show&quot;&gt;toggle&lt;/button&gt; &lt;/div&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; show:true &#125;&#125;) v-for:绑定数组的数据来渲染一个项目列表 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;v-for演示&lt;/h1&gt; &lt;div v-for=&quot;item in items&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;div v-for=&quot;item,index in items&quot;&gt;&#123;&#123;index&#125;&#125;,&#123;&#123;item&#125;&#125;&lt;/div&gt;&lt;/div&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; items:[&apos;前&apos;,&apos;端&apos;,&apos;大&apos;,&apos;法&apos;,&apos;好&apos;] &#125;&#125;) v-on:绑定各种事件 使用很简答：格式是v-on:evnet=”fun” event就是你能想到的常用的事件名称，fun是一个函数 必须将这些你想绑定的函数放在vue实例中的methods属性中，methods是一个对象 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;cli&quot;&gt;点我&lt;/button&gt; &lt;input type=&quot;text&quot; v-on:blur=&quot;bl&quot;&gt; &lt;select name=&quot;&quot; id=&quot;&quot; v-on:change=&quot;chg&quot;&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;&quot;&gt;4&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;var app = new Vue(&#123; el:&apos;#app&apos;, methods:&#123; cli: function () &#123; alert(&apos;you are the best!&apos;) &#125;, bl: function () &#123; alert(&apos;你失去了焦点&apos;) &#125;, chg: function () &#123; alert(&apos;你改变了select&apos;) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>v-bind</tag>
        <tag>v-model</tag>
        <tag>v-if</tag>
        <tag>v-else</tag>
        <tag>v-on</tag>
        <tag>v-for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的Jquery 阅读第一天]]></title>
    <url>%2F2017%2F07%2F31%2Fjquery%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一章 认识jquery1.1 JavaScript和JavaScript库1.1.1 JavaScript简介JavaScript是Netscape公司开发的一种脚本语言（scrpting language） 1.1.2 JavaScript库 Prototype(http://www.prototypejs.org),是最早成型的JavaScript库之一，但是由于Prototype成型年代较早，从整体上对面向对象的编程思想把握得不是很到位，导致了其结构的松散。 Dojo(http://dojotoolkit.org),是一款非常适合企业级应用的javascript库，得到了IBM、SUN和BEA等一些大公司的支持，Dojo缺点就是：学习曲线陡，文档不齐全，最严重的就是API不稳定，每次升级都可能导致已有的程序失效。 YUI(http://developer.yahoo.com/yui)，是由yahoo公司开发的，YUI封装了一系列比较丰富的功能，例如DOM操作和Ajax应用等。 Ext JS(http://www.extjs.com)，简称Ext，可以用来开发富有华丽外观的客户端应用，能使B/S应用更加具有活力，Ext并非完全免费，如果用于商业用途，需要付费获得授权许可。 MooTools(http://mootools.net)，是一套轻量、简洁、模块化和面向对象的javascript框架，模块化思想非常优秀，核心代码大小只有8KB jQuery(http://jquery.com)，轻量级的库，拥有强大的选择器、出色的DOM操作、可靠的事件处理、完善的兼容性和链式操作等功能，jQuery逐渐从其他javascript库中脱颖而出，成为web开发人员的最佳选择。1.2 加入jquery1.2.1 jquery简介jquery是一个由John Resig创建于2006年1月的开源项目1.2.2 jquery优势jquery强调的理念是写得少，做得做 (1) 轻量级，采用UglifyJS压缩后，大小保持在30KB。 (2) 强大的选择器，允许开发者使用从css1到css3几乎所有的选择器，以及jquery独创的高级而复杂的选择器。 (3) 出色的DOM操作的封装，jquery封装了大量常用的DOM操作，开发者在编写DOM操作相关程序的时候能够得心应手。 (4) 可靠的事件处理机制。 (5) 完善的Ajax，jquery将所有的ajax操作封装到一个函数$.ajax()里，使得开发者处理ajax的时候能够专心处理业务逻辑而无需关心复杂的浏览器兼容性和XMLHttpRequest对象的创建和使用的问题。 (6) 不污染顶级变量，jquery只建立一个名为jquery的对象，其所有的函数方法都在这个对象之下，其别名$也可以随时交出控制权，绝对不会污染其他的对象。 (7) 出色的浏览器兼容性，jquery能够在IE6.0+,FF3.6+,Safari5.0+,Opera和Chrome等浏览器下正常运行。 (8) 链式操作方式，对发生在同一个jquery对象上的一组动作，可以直接连写而无需重复获取对象。 (9) 隐式迭代，当用jquery找到带有“.myClass”类的全部元素，然后隐藏它们时，无需循环遍历每一个返回的元素。 (10) 行为层与结构层的分离，开发者可以使用jquery选择器选中元素，然后直接给元素添加事件 (11) 丰富的插件支持，目前已经有上千的官方插件支持，而且还不断有新插件面世。 (12) 完善的文档，jquery的文档非常丰富，英文文档，中文文档。 (13) 开源，jquery是一个开源的产品，任何人都可以自由的使用并提出改进意见。 1.3 jquery代码编写1.3.1 jquery环境jquery库的类型分为两种，分别是生产版(最小化和压缩版)和开发版(未压缩版)，区别在于：开发版是完整无压缩版本，主要用于测试、学习和开发；生产版是主要应用于产品和项目。 1.3.2 编写简单的jquery代码在jquery库中，$就是jquery的一个简写形式，$.ajax和jQuery.ajax是等价的。 12$(document).ready(function&#123;&#125;) //等待dom元素加载完毕 这行代码类似于传统javascript中的window.onload方法 两者的区别： window.onload：必须等待网页中所有的内容加载完毕后（包括图片）才能执行，不能同时编写多个代码 123window.onload=function()&#123;alert(&quot;test1&quot;)&#125;;window.onload=function()&#123;alert(&quot;test2&quot;)&#125;;//结果只会输出“test2” $(document).ready():网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完，能同时编写多个代码 123$(document).ready(function&#123;alert(&quot;test1&quot;);&#125;);$(document).ready(function&#123;alert(&quot;test2&quot;);&#125;);//结果两次都会输出 1.3.3 jquery代码风格链式操作风格 123456789101112$(&quot;.level&gt;a&quot;).click(function()&#123; $(this).addClass(&quot;current&quot;) //给当前元素添加 current样式 .next().show() //下一个元素显示 .parent().siblings().children(&quot;a&quot;).removeClass(&quot;current&quot;)//父元素的同辈元素的子元素&lt;a&gt;移除current样式 .next().hide(); //它们的下一个元素隐藏&#125;);//这段代码的作用：当鼠标点击到a元素（它是class含有level的子元素）的时候，给其添加一个名为current的class，然后将紧邻其后面的元素显示出来，同时将它的父辈的同辈元素内部的子元素&lt;a&gt;都去掉一个名为current的class，并且将紧邻它们后面的元素都隐藏。 这就是jquery强大的链式操作，一行代码就完成了导航栏的功能。 总结3种情况： (1) 对于同一个对象不超过3个操作的，可以直接写成一行12$(&quot;li&quot;).show().unbind(&quot;click&quot;);//unbind--从每一个匹配的元素中删除绑定的事件 (2) 对于同一个对象的较多操作，建议每行写一个操作12345678910$(this).removeClass(&quot;mouseout&quot;) .addClass(&quot;mouseover&quot;) .stop() .fadeTo(&quot;fast&quot;,0.6) .fadeTo(&quot;fast&quot;,1) .unbind(&quot;click&quot;) .click(function()&#123; //do something... &#125;);//fadeTo--把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数 (3) 对于多个对象的少量操作，可以每个对象写一行，如果涉及子元素，可以考虑适当缩进12345$(this).addClass(&quot;highlight&quot;) .children(&quot;li&quot;).show().end().siblings().removeClass(&quot;highlight&quot;) .children(&quot;li&quot;).hide();//end() 将匹配的元素列表变为前一次的状态 为代码添加注释 给代码加上注释，无论是自己日后阅读还是与他人分享、合作开发，注释都能起到良好的效果，加上注释就能提高其易读性。12345//在一个id为table的表格的tbody中，如果每行的一列中的checkbox没有被禁用，则把这行的背景设为红色//enabled--可以使用（激活的元素）$(&quot;#table&gt;tbody&gt;tr:has(td:has(:checkbox:enabled))&quot;).css(&quot;background&quot;,&quot;red&quot;); 1.4 jquery对象和DOM对象1.4.1 DOM对象和jquery对象简介1. DOM对象 DOM(Document Object model)，即文档对象模型，每一份DOM都可以表示成一棵树。123456&lt;p tittle=&quot;选择你喜欢的水果&quot;&gt;你喜欢的水果是？&lt;/p&gt;&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt;&lt;/ul&gt; 可以把上面的html结构描述为一颗DOM树，如下图： 在这颗DOM树中，&lt;p&gt;,&lt;ul&gt;,&lt;li&gt;都是DOM元素节点，可以通过javascript中的getElementsByTagName或者getElementById来获取元素节点。 12var domObj = document.getElementById(&quot;id&quot;); //获得DOM对象var ObjHTML = domObj.innerHTML; //使用javascript中的属性--innerHTML 2. jquery对象jquery对象就是通过jquery包装DOM对象后产生的对象。 jquery对象是jquery独有的。123$(&quot;#foo&quot;).html(); //获取id为foo的元素内的html代码，html()是jquery方法//这段代码等同于document.getElementById(&quot;foo&quot;).innerHTML; 在jquery对象中无法使用DOM对象的任何方法。 例如：$(&quot;#id&quot;).innerHTML和$(&quot;#id&quot;).checked之类的写法是错误的 可以用“$(&quot;#id&quot;).html()和$(&quot;#id&quot;).attr(&quot;checked&quot;) //attr--设置属性”之类的jquery方法来代替。 1.4.2 jquery对象和DOM对象的相互转换1.jquery对象转成DOM对象jquery提供了两种方法将jquery对象转换成DOM对象，即[index]和get(index)(1)jquery对象是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象123var $cr = $(&quot;#cr&quot;); //jquery对象var cr = $cr[0]; //DOM对象alert(cr.checked); //检测这个checkbox是否被选中了 (2)另一种方法是jquery本身提供的，通过get(index)方法得到相应的DOM对象 2.DOM对象转成jquery对象对于一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jquery对象了。方式为$(DOM对象)。12var cr = document.getElementById(&quot;cr&quot;); //DOM对象var $cr = $(cr); //jquery对象 通过以上方法，可以任意的相互转换jquery和DOM对象。 强调：DOM对象才能使用DOM中的方法，jquery对象不可以使用DOM中的方法。 平时用到的jquery对象都是通过$()函数制造出来的，$()函数就是一个jquery对象的制造工厂。 1.4.3 jquery实例研究12345678910111213141516&lt;input type=&quot;checkbox&quot; id=&quot;cr&quot; /&gt;&lt;label for=&quot;cr&quot;&gt;我已阅读提示&lt;/label&gt;$(&quot;#cr&quot;).click(function()&#123; if($(&quot;#cr&quot;)[0].checked)&#123; alert(&quot;谢谢！&quot;); &#125;&#125;)$(document).ready(function()&#123; var $cr = $(&quot;#cr&quot;); var cr = $cr[0]; $cr.click(function()&#123; if(cr.checked)&#123; alert(&quot;谢谢!&quot;); &#125; &#125;)&#125;) //用DOM方式来判断复选框是否被选中 以上2个方法都是相同的实践功能123456789//使用jquery方法判断复选框是否被选中$(document).ready(function()&#123; var $cr = $(&quot;#cr&quot;); $cr.click(function()&#123; if($cr.is(:checked))&#123; //.is--jquery方法，判断是否被选中，返回boolean值 alert(&quot;谢谢！&quot;); &#125; &#125;)&#125;) DOM对象和jquery对象不同，但是通过转换，最终的效果是一样的。 1.5 解决jquery和其他库的冲突在jquery库中，几乎所有的插件都被限制在它的命名空间里，全局对象都被很好的存在jquery命名空间里，因此当把jquery和其他javascript库一起使用，不会引起冲突。 1. jquery库在其他库之后导入在其他库和jquery库都被加载完毕后，可以在任何时候调用jquery.noConflict()函数来将变量$的控制权移交给其他javascript库。123456789jQuery.noConflict(); //将变量$的控制权移交给prototype.jsjQuery(function()&#123; //使用jquery jQuery(&quot;p&quot;).click(function()&#123; alert(jQuery(this).text()); &#125;)&#125;)$(&quot;pp&quot;).style.display=&apos;none&apos;; //使用prototype.js 隐藏元素//prototype.js 是一个非常优雅的javascript基础类库//... 就可以在程序里将jquery()函数作为jquery对象的制造工厂了 另一种选择，如果想确保jquery不会与其他库冲突，但又想自定义一个快捷方式，如下操作:123456789//...var $j = jQuery.noConflict(); //自定义一个快捷方式 $j(或者jq、$J等)$j(function()&#123; //使用jquery，利用自定义快捷方式 $j(&quot;p&quot;).click(function()&#123; alert($j(this).text()); &#125;)&#125;)$(&quot;pp&quot;).style.display=&apos;none&apos;; //使用prototype.js 隐藏元素//... 如果不想给jquery子你故意的这些备用名称，还想使用$而不管其他库的$()方法，又不想冲突，以下两种解决方法都可以： 第一种：12345678//...jQuery.noConflict(); //将变量$控制权过渡给prototype.jsjQuery(function($)&#123; //使用jquery设定页面加载时执行的函数 $(&quot;p&quot;).click(function()&#123; //在函数内部继续使用$()方法 alert($(this).text()); &#125;)&#125;)$(&quot;pp&quot;).style.display=&apos;none&apos;; //使用prototype 第二种：123456789jQuery.noConflict(); //将变量$控制权过渡给prototype.js(function($)&#123; //定义匿名函数并设置形参为$ $(function()&#123; //匿名函数内部的$均为jQuery $(&quot;p&quot;).click(function()&#123; //继续使用$()方法 alert($(this).text()); &#125;); &#125;);&#125;)(jQuery); //执行匿名函数且传递实参jquery$(&quot;pp&quot;).style.display=&apos;none&apos;; //使用prototype 2. jquery库在其他库之前导入如果jquery库在其他库之前就导入了，那么可以直接使用jquery来做一些jquery的工作，同时可以使用$()方法作为其他库的快捷方式，无需调用jquery.noConflict()函数。123456jquery(function()&#123; //直接使用jquery，无需调用jquery.noConflict()函数 jquery(&quot;p&quot;).click(function()&#123; alert(jquery(this).text()); &#125;)&#125;)$(&quot;pp&quot;).style.display=&apos;none&apos;;]]></content>
      <categories>
        <category>锋利的Jquery</category>
      </categories>
      <tags>
        <tag>DOM对象</tag>
        <tag>jquery对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级 第三天]]></title>
    <url>%2F2017%2F07%2F31%2Fjs-senior03%2F</url>
    <content type="text"><![CDATA[1. JavaScript面向对象的继承： 类式继承：将父类的实例赋值给子类的原型 12SubClass.prototype = new SupClass()//缺点：子类实例共用父类实例私有属性的引用类型属性部分 构造函数继承：将父类的构造函数在子类的构造函数中执行一遍 1234function SubClass()&#123; SuperClass.call(this)&#125;//缺点：子类实例无法使用父类原型上的扩展方法 组合继承: 将类式继承和构造函数继承结合在一起的继承方式 1234 function SubClass()&#123;SuperClass.call(this) &#125; SubClass.prototype = new SuperClass() 2. JavaScript的多态： 可以通过一些技巧实现多态12345678910111213141516171819//利用arguments对象来实现js的多态 如果传入一个参数则返回10的n次方 两个参数则返回x的n次方,n为正整数function pow(n,x)&#123; var l = arguments.length if(l&gt;2) l = 2 function _f(n,x) &#123; if(n&lt;=0) return &apos;n为正整数&apos; if(n==1) return x return x*_f(n-1,x) &#125; switch(l)&#123; case 1: return _f(n,10) case 2: return _f(n,x) &#125;&#125; 3. Javascript的模块: Common.js规范：nodejs的模块就是根据此规范实现的，针对服务器，这个规范定义了一个require（）的方法 1var $ = require(&apos;jquery&apos;) AMD规范：实现：require.js 123456789Require.js的用法： 1.导入原文件 (a)使用require([ …],function(…)&#123; ... &#125;) (b)使用define([…],function(…)&#123; ... &#125;) //此方法会定义一个模块 *CMD规范：实现：sea.js es6的模块]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级 第四天]]></title>
    <url>%2F2017%2F07%2F31%2Fjs-senior04%2F</url>
    <content type="text"><![CDATA[1. Js的第七种数据类型 symbol每一个通过symbol生成的数据都是独一无二的，所以不用担心重名的问题以Symbol数据类型为对象键名的时候，无法被for-of或者for-in遍历出来同样也不会被遍历器方法返回（entry() keys()之类的方法）Object.getOwnPropertySymbols( obj )这个方法返回一个数组，里面包含所有symbol属性的键名 *以Symbol类型为键名的键值转字符串会报错 2. Symbol.for()/Symbol.keyfor()每一个通过Symbol（）创建的symbol类型的值都是独一无二的，即便是传入相同的参数或者不传，两个symbol值都是不相等的 而通过Symbol.for()方法创建的symbol值，传入相同的参数名如Symbol.for(‘foo’)，则两次调用返回的symbol值 s1和s2是相等的 本质：在调用Symbol.for的时候，会先去找，如果找到就返回该值，如果找不到，就创建一个新的 3. Js中的异步在es6之前，我们处理异步的方式有如下几种： 回调 事件 Es6提供了 Promise来解决异步问题 12345function * f()&#123; yield … yield … return …&#125; Generator函数在执行的时候并没有真正执行，只是返回了一个遍历器对象 我们可以通过对遍历器对象调用next方法来跑generator函数的内部代码 每调用一次next，对应的generator函数就会从上一次执行的代码结尾处（或函数开头）开始执行，直到遇到下一个yield语句或者return语句，如果遇到yield语句，会将yield语句后面的表达式的值返回，如果遇到return语句，同样会将return后面的表达式的值当成返回值返回，并将返回对象的done置为false Next方法的参数 Yield表达式本身没有返回值，或者说返回值为undefined Next()所传入的参数会被赋值给当前yield表达式的返回值]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>symbol</tag>
        <tag>Promise</tag>
        <tag>Generator</tag>
        <tag>Next</tag>
        <tag>yield</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级 第五天]]></title>
    <url>%2F2017%2F07%2F31%2Fjs-senior05%2F</url>
    <content type="text"><![CDATA[1. PromisePromise是用来解决异步编程的一个规范，Bluebird的库就实现了promise，随后2015年发布的es2015（es6）就已经实现了promise对象 对象的状态不受外界影响 一个promise会有如下三种状态(只会在这三种状态中取一): pending(进行中) resolved(已完成) rejected(已拒绝) (只有promise内部决议方法可以改变promise的状态) 状态一经更改，不会再变 Promise的状态改变只有两种可能： pending =&gt;resolved pending =&gt;rejected 2. Promise构造函数接收方法Promise.all([ p , p2, p3]) 该方法接收一个promise数组，返回一个大promise 外层大promise的决议结果等于传入promise数组内的所有Promise决议的“与”运算的值1234567891011121314151617181920212223242526272829303132333435363738394041function learnHtmlAndCss() &#123; return new Promise(function (resolve,reject) &#123; console.log(&apos;开始学习html和css&apos;) setTimeout(function () &#123; if (Math.random()&gt;0.5) &#123; console.log(&apos;html和css基础我学会啦&apos;) resolve(&apos;get them(html css基础)&apos;) &#125; else &#123; console.log(&apos;学习css和html失败&apos;) reject(&apos;学习css和html失败&apos;) &#125; &#125;,7000) &#125;)&#125;function learnJavascriptBase() &#123; return new Promise(function (resolve,reject) &#123; console.log(&apos;开始学Javascript基础&apos;) setTimeout(function () &#123; if (Math.random()&gt;0.5) &#123; console.log(&apos;js基础我学会啦&apos;) resolve(&apos;get them(javascript base)&apos;) &#125; else &#123; console.log(&apos;学习js基础失败&apos;) reject(&apos;学习js基础失败&apos;) &#125; &#125;,3000) &#125;)&#125;function learnFrontEnd(...arr) &#123; return Promise.all(arr)&#125;learnFrontEnd(learnJavascriptBase(),learnHtmlAndCss()).then( function (datas) &#123; console.log(&apos;学业已成&apos;) console.log(datas) &#125;, function (error) &#123; console.log(&apos;失败,请努力&apos;) console.log(&apos;失败原因：&apos;+error) &#125;) Promise.race([p, p2, p3]) 该方法接收一个promise数组，返回一个大promise，外层大promise的决议结果等于传入promise数组内的第一个决议的promise的决议结果1234567891011121314151617181920212223242526272829303132333435363738394041function learnHtmlAndCss() &#123; return new Promise(function (resolve,reject) &#123; console.log(&apos;开始学习html和css&apos;) setTimeout(function () &#123; if (Math.random()&gt;0.5) &#123; console.log(&apos;html和css基础我学会啦&apos;) resolve(&apos;get them(html css基础)&apos;) &#125; else &#123; console.log(&apos;学习css和html失败&apos;) reject(&apos;学习css和html失败&apos;) &#125; &#125;,7000) &#125;)&#125;function learnJavascriptBase() &#123; return new Promise(function (resolve,reject) &#123; console.log(&apos;开始学Javascript基础&apos;) setTimeout(function () &#123; if (Math.random()&gt;0.5) &#123; console.log(&apos;js基础我学会啦&apos;) resolve(&apos;get them(javascript base)&apos;) &#125; else &#123; console.log(&apos;学习js基础失败&apos;) reject(&apos;学习js基础失败&apos;) &#125; &#125;,3000) &#125;)&#125;function learnSkill(...arr) &#123; return Promise.race(arr)&#125;learnSkill(learnHtmlAndCss(),learnJavascriptBase()).then( function (d) &#123; console.log(d) console.log(&apos;该去学习了&apos;) &#125;, function (e) &#123; console.log(e) console.log(&apos;继续努力&apos;) &#125;) then(f1,f2)方法将会返回一个新的Promise对象，意味着可以链式调用在then方法中f1代表成功回调，f2代表失败回调而在f1和f2中返回值或函数本身运行的状态会影响下一个then方法的抉择而不是抉择f1和f2抉择了下一个then方法的抉择说白了每一个then方法中包含了某个动作 这个动作可能是在成功回调中也可能出现在失败回调中，也可能是独立的两个动作，但是这个then方法只可能走其中一个动作，且这个动作的成功或者失败决定了下一个then方法选择成功回调或者失败回调，而非这个动作出现在上一个then方法的成功回调还是失败回调决定下一个then方法的抉择 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var p = new Promise(function (resolve,reject) &#123; var r =Math.random() if (r&gt;0.5) &#123; resolve(r) &#125; else &#123; reject(r) &#125;&#125;)p.then(function (data) &#123; console.log(&apos;data:&apos;+data)&#125;,function (err) &#123; console.log(&apos;err:&apos;+err)&#125;)var o = new Promise(function (resolve,reject) &#123; setTimeout(function() &#123; resolve(&apos;promise&apos;) &#125;, 500);&#125;)o.then( function (data) &#123; console.log(&apos;data:&apos;+data) return &apos;second promise&apos; &#125;, function (err) &#123; console.log(&apos;err:&apos;+err) &#125;).then( function (d) &#123; console.log(&apos;d:&apos;+d) &#125;, function (e) &#123; console.log(&apos;e:&apos;+e) &#125;)var getUp = new Promise(function (resolve,reject) &#123; var r = Math.randow() if (r&gt;0.5) &#123; resolve(&apos;起床成功&apos;) &#125; else &#123; reject(&apos;起床失败&apos;) &#125;&#125;)getUp.then( function (d) &#123; console.log(&apos;d:&apos;+d) &#125;, function (e) &#123; console.log(&apos;e:&apos;+e) &#125;)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>then</tag>
        <tag>resolve</tag>
        <tag>reject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas]]></title>
    <url>%2F2017%2F07%2F31%2Fcanvas%2F</url>
    <content type="text"><![CDATA[Canvas:使用方法：在页面创建一个canvas标签 然后给他的width 和height赋值 //canvas元素必须有一个id document.write(&apos;&lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border:1px solid red&quot;&gt;&lt;/canvas&gt;&apos;) var canvas = document.getElementById(&apos;canvas&apos;) var ctx = canvas.getContext(&apos;2d&apos;) ctx.fillStyle = &apos;red&apos; ctx.fillRect(10,10,40,40) 用法： 1.先获取canvas dom对象canvas 2.用dom对象canvas自带的api getContext(‘2d’)获取一个画笔ctx 3.此时我们就可以用ctx的内置api来画图了ctx.fillStyle改变画笔填充颜色，ctx.fillRect( x,y , w,h)，画一个矩形，xy代表矩形左上角的那个起始点，w代表矩形宽，h为高，ctx.font = “80px 幼圆” 改变画笔插入文本框的字体大小和字体风格， ctx.fillText(‘文本’，x,y) 用画笔在画布上添加文本，x,y为文本框左下角的起始点 ctx.clearRect(x,y,w,h) 清楚一个矩形区域内的所有东西，xy为矩形左上角起始点，w，h为矩形宽高]]></content>
      <categories>
        <category>Html5</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAscipt6 es6第一天]]></title>
    <url>%2F2017%2F07%2F31%2FES601%2F</url>
    <content type="text"><![CDATA[1. ECMAsript6 es6 let 和 const 用来声明变量的两个新关键字 let : 1. 不存在变量提升 2.不可以重复声明 3.暂时性死区 4.在块级作用域之外无法访问 const: 1.和let一样的特点 2.用来声明常量，一经赋值，不能更改 3.声明时必须同时赋值 否则报错 4.当const 声明的常量为引用数据类型时，指向的其实是地址，所以可以修改地址指向的数据的内容，但是不能重新指向一个新的数据 5.根据习惯，我们用const命名的变量都是全部大写如PI,GENDER 解构赋值：通过模式匹配去取值赋值 数组的解构赋值： 1.对号入座 [a,b,c] = [1,2,3] a=1 b=2 c=3 2.没有就undefined [a,b,c] = [1] a=1 b=undefined c=undefined 3.可以设置默认值 [a,b=’b’,c=’c’] = [‘a’] a=’a’ b=’b’ c=’c’ 对象的解构赋值： 1.根据键名匹配 2.本质是将匹配到的键名所对应的值赋值给变量，牢记变量的位置 字符串的解构赋值： 1.可以取出一个字符串上的每个字符 2.取出字符串的长度 数值和布尔值的解构赋值： 1.会将数值和布尔值转换成包装对象 函数的解构赋值： 1.默认值 for-of与for-in for-of : 遍历键值 （数组，字符串）可以用for-of的是因为这个对象有遍历器接口 for-in : 遍历键名 （数组，字符串，对象）]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
        <tag>const</tag>
        <tag>for-of</tag>
        <tag>for-in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级 第一天]]></title>
    <url>%2F2017%2F07%2F31%2Fjs-senior01%2F</url>
    <content type="text"><![CDATA[1. 函数是js中的一等公民 函数可以作为方法，封装一段可以重复使用的代码. 在js中，函数也是对象，js的面向对象是通过函数实现的. 在js中，函数可以用来传递数据.123456789101112function f(x)&#123; var xx if(!x)&#123; xx = 100 &#125;else&#123; xx = x &#125; return function(n)&#123; console.log(Math.pow(xx,n)) &#125;&#125;//Javascript的作用域是函数级作用域，无块级作用域 2.定义一个函数的几种方法 var f =function(){} function f(){} new Function()/Function(){} 匿名函数与立即执行函数 123456(function()&#123; //...something&#125;)() //匿名函数!function()&#123; //...something&#125;() //立即执行函数 例子(匿名函数与闭包) 123456789101112var lunbo = (function()&#123; var page = 11 var ctx =1 function run()&#123; console.log(&apos;run&apos;) &#125; return&#123; page : page, ctx : ctx, run : run &#125;&#125;)() 3.变量提升 变量声明，函数声明语句会提前 12345678console.log(str) //打印出：aaavar str = &apos;aaa&apos;console.log(str) //打印出：undefinedvar strconsole.log(str) //打印出：undefinedstr = &apos;bbb&apos;console.log(str) //打印出：bbb 函数声明优先级高于变量声明(当重名时，变量声明会被自动忽略) js是基于事件机制的的单线程语言12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455同步队列:[line1,line2,line3]异步队列:[setTimeout]//基于异步的js小游戏，技能血量防御攻击，根据防御攻击血量，最终谁获得胜利function factory(name,attack,defence,health,skill) &#123; this.name = name; this.attack = attack; this.defence = defence; this.health = health; this.skill = skill; var zet = this ; this.fight = function (target) &#123; var meReduce = target.attack - this.defence var tarReduce = this.attack - target.defence var meBeated = Math.ceil(this.health/meReduce) var tarBeated = Math.ceil(target.health/tarReduce) var turns = tarBeated &gt;= meBeated ? meBeated : tarBeated var win = turns == meBeated ? &apos;tar&apos; : &apos;me&apos; var healthM = this.health var healthT = target.health for(var i = 1 ; i&lt;=turns; i++)&#123; healthM -= meReduce healthM = healthM &lt; 0 ? 0 : healthM !function (a,n) &#123; setTimeout(function()&#123; console.log(target.name + &apos;使出&apos;+target.skill+&apos;,对&apos;+zet.name+&apos;造成了&apos;+meReduce+&apos;的伤害,&apos;+zet.name+&apos;剩余生命值为:&apos;+a) &#125;,1000*n) &#125;(healthM,i) if(win == &apos;tar&apos; &amp;&amp; i== turns)&#123; !function (n) &#123; setTimeout(function () &#123; console.log(target.name+&apos;赢了！&apos;) &#125;,1000*n) &#125;(i) break &#125; healthT -= tarReduce healthT = healthT &lt; 0 ? 0 : healthT !function (b,n) &#123; setTimeout(function () &#123; console.log(zet.name+&apos;使出&apos;+zet.skill+&apos;对&apos;+target.name+&apos;造成了&apos;+tarReduce+&apos;的伤害,&apos;+target.name+&apos;剩余生命值为:&apos;+b) &#125;,1000*n) &#125;(healthT,i) if(win == &apos;me&apos; &amp;&amp; i == turns)&#123; !function (n) &#123; setTimeout(function () &#123; console.log(zet.name+&apos;赢了！&apos;) &#125;,1000*n) &#125;(i) &#125; &#125; &#125;&#125;var zilong = new factory(&apos;紫龙&apos;,10,10,100,&apos;庐山升龙霸&apos;);var xingshi = new factory(&apos;星矢&apos;,12,-7,110,&apos;天马流星拳&apos;);zilong.fight(xingshi);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>定义函数</tag>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAscipt6 es6第二天]]></title>
    <url>%2F2017%2F07%2F31%2FES602%2F</url>
    <content type="text"><![CDATA[1. ES6的模块系统Es6的模块系统现在浏览器还玩不了，需要将写有es6模块系统代码的文件重新编译成浏览器可以识别的低版本js才能运行 Es6的模块主要就是两个关键字 export和import Export是导出（暴露）数据，Import是导入数据 Export方法请记住两种用法: export default +数据 （数据可以是所有数据类型） export { } 对象里面是数据 import方法请记住两种用法，分别对应export的两种用法: import 变量名 from 路径,此时 变量名你可以任意去取名 路径是相对路径的字符串,此时该变量名对应的变量获得的就是路径对应模块所export default出来的数据 import { 变量名 } from 路径,此时变量名要想获得数据，则应该和路径对应的模块所 export {。。。。} 内部的变量名对应，只要对应上了，就可以拿到相应的值，这种场景针对你希望获得某个模块的部分功能，而不是加载整个模块]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Export</tag>
        <tag>Import</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级 第二天]]></title>
    <url>%2F2017%2F07%2F31%2Fjs-senior02%2F</url>
    <content type="text"><![CDATA[1. Javascript中的this 在全局作用域下this指向window(浏览器环境)或global(服务器环境)(tip:当在严格模式下,this无法指向全局对象) 对象方法下的this，这时候的this指向调用方法的对象 在实例化一个对象时，this指向新的对象 12345var me = new Human()//new 操作符做的事情：//1.创建一个空对象，作为返回的对象//2.将这个空对象赋值给函数中的this//3.在一般情况下，返回该this call/apply中的this指向第一个参数(这两个方法的作用就是更改函数内this的指向) bind方法中的this指向第一个参数，可以用bind实现函数的科里化2. arguments对象arguments是一个方法内部的对象，它是所有传入参数的集合，有点像数组但不是数组3. js的面向对象 js是基于原型(prototype)的语言 一个类的私有属性，私有方法，实例属性，实例方法，静态属性，静态方法]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>call/apply</tag>
        <tag>arguments</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
</search>